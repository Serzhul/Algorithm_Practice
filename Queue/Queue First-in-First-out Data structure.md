# 큐(Queue) : First-in-First-out 자료구조

# 선입선출 자료구조(First-in-first-out Data Structure)

![https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/03/screen-shot-2018-05-03-at-151021.png](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/03/screen-shot-2018-05-03-at-151021.png)

FIFO(First-in-First-out) 자료구조에서는 `큐에 추가된 첫번째 요소가 제일 먼저 진행된다`.

 위 그림에서 보듯, 큐는 전형적인 FIFO 자료구조이다. 삽입 기능은 enqueue라고도 불리며, 새로운 요소는 항상 `큐의 마지막에 추가 된다.` 삭제 기능은 dequeue라고 불린다. `첫번째 요소만 제거할 수 있다`.

 큐를 구현하기 위해선, 동적인 배열과 큐의 head를 가리키는 index가 필요하다.

 큐는 enqueue와 dequeue를 지원하는데, Enqueue는 새로운 요소를 큐에 추가하는 것이고, dequeue는 첫번째 요소를 제거하는 것이다. 따라서, 첫번째 시작점을 가리키는 인덱스가 필요하다. 

# **Queue 와 BFS**

 너비우선탐색(BFS)와의 공통 분모는 루트 노드부터 타겟 노드까지의 가장 짧은 길을 찾는 방법이라고 할 수 있다. 

# 인사이트

---

1. 노드의 순서는 어떻게 진행 되는가? ****

첫 번째 단계에서, 먼저 루트 노드를 진행한다. 두 번째 단계에서는 루트 노드의 옆에 있는 노드들을 진행한다.

세 번째 단계에서는 루트 노드에서 두 단계 진행한 노드들로.. 등등

 트리 탐색과 유사하며, `루트 노드와 가까운 노드들을 먼저 탐색한다`. 

 만약 노드 X가 k 번째 단계에 큐에 추가되었다면, 루트 노드와 X의 가장 가까운 경로의 길이는 K이다. 즉, 타겟 노드를 찾은 시점에 가장 짧은 경로에 있다는 것이다. 

**2. 큐의 enqueue와 dequeue의 순서는 어떻게 되는가?**

 먼저 루트 노드를 enqueue한다. 그리고 각 단계마다 이미 큐에 있는 노드들을 하나씩 진행하며, 이웃 노드들을 큐에 추가한다. 새롭게 추가된 노드들은 아무런 의미도 없지만 당장엔 탐색하지 않고 다음 단계에 진행하게 된다.

 노드들의 진행순서는 정확히 추가된 순서로 진행되며(FIFO), 이것이 BFS에서 큐를 사용하는 이유이다.